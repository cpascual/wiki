NXTOFRW - A proposal for a NeXus Time-of-Flight Raw Data File Format

==Introduction==

[http://www.nexus.anl.gov/ NeXus] is moving onto the idea of inherited incremental definitions as discussed at the last meeting of the [http://www.nexus.anl.gov/nexus_committee.html NeXus International Advisory Committee (NIAC)] – for example with powder diffractometers there is a definition for both time focussing and total scattering with one being a subset of the other; a file can conform to one or both. The initial work on this definition comes from discussions between [http://www.sns.gov/ SNS], [http://j-parc.jp/index-e.html J-PARC] and [http://www.isis.rl.ac.uk/ ISIS] -
the three facilities are interested in having a unified base for all instruments to allow for low level instrument debugging tools to be used, without change, in a given facility.

There are example files in [http://nexus.isis.rl.ac.uk/hrp08639.nx4 HDF4] and [http://nexus.isis.rl.ac.uk/hrp08639.nx5 HDF5] available.

==Goal of the Definition==

The definition/format should: 
* Be general i.e. not specific to any particular instrument type and so can be used as a common root/parent format across all instruments at a facility 
* allow the sharing of diagnostic and “first look” data/detector display programs between the facilities. 
* provide a common input format to metadata capture programs (such as the ISIS ICAT search interface) 

With the above in mind the instrument components of most importance are the ones related to the detector, data, user, sample and sample conditions; other instrument components are, of course, needed for analysis but will be covered by specific NeXus instrument definitions. The NeXus classes we will ultimately consider are then:

<pre>
NXroot
NXdata
NXdetector
NXentry
NXgeometry
NXinstrument
NXlog
NXmoderator
NXmonitor
NXsample
NXuser
NXevent_data 
NXsource
NXdetector_group (proposed)
</pre>

Some of these classes, such as NXgeometry, are taken directly from what was ratified by the [http://www.nexus.anl.gov/nexus_committee.html NIAC].

==Conventions Used in this Document==

A tabular format is used for ease of viewing and printing rather than the [http://www.nexus.anl.gov/nexus_metaformat.html NeXus XML meta-DTD format].
The Name column in a table identifies an item in an instance of a NeXus class. Items can have extra “meta data” associated with them, which are called attributes – these, if any, are listed in the next few lines in the attributes column. Any variables in the attributes column are always attached to the previous variable in the Name column above them; if the Name of the variable is the same as the class (e.g. NXfile), then the attributes are associated with an instance of that class (global) and not to any of its specific members.

===Identifying Mandatory and Optional Components===
The following convention will be used:
* Variables in '''bold''' in the Name column of tables are mandatory – they must be present in ALL NeXus files; otherwise they are optional and their inclusion will depend on the instrument, experiment or presence of other items in the class (see the class description of usage)
* Variables in ''{italics}'' in the Name column are examples of names and any variable name can in fact be used; variable names in normal type mean that exact name must be used
* Anything in <font color=red>red</font> is currently an extension to NeXus

This information is also included in a RE column (the name derives from the fact that a “Regular Expression” is used here in the [http://www.nexus.anl.gov/nexus_metaformat.html  XML DTD format]). Thus:

{| align="centre" border="1"
|-
! Font/style in Name Column || RE Column || Meaning || XML DTD symbol
|- 
| Something || 0/1 || A single instance of this variable may be present (optional) – if it is, it must be called  "something" || ?
|- 
| '''Something''' || 1 || A single instance of this variable must be present (mandatory) and called “something” || &nbsp;
|- 
| ''{Something}'' || 0+ || Zero or more variables of this type/class may be present (optional) and can have any unique name(s)	|| *
|- 
| '''{Something}''' || 1+ || One or more variables of this type/class must be present (mandatory), but can have any name(s)	|| +
|}

The above convention dictates that the name for any item that occurs only 0 or 1 times is fixed; this is not required by the current NeXus standard, but would add clarity and ease of location if followed.

===Naming===

We will try and name logged variables (type NXlog) such that they end in the _log suffix
 
==NeXus Classes==

===NXroot===
The root is not a real class in the NeXus file, it is a convenient name under which to group the global attributes of the file. This is taken directly from the NeXus technical reference without change.

{| align="centre" border="1"
|-
! RE	|| Name	|| Attribute	|| Type	|| Value	|| Description
|-
| 1	||&nbsp; ||	NeXus_version	|| NX_CHAR	|| &nbsp; || &nbsp;	
|-
| 0/1	||&nbsp; ||	HDF_version	|| NX_CHAR	|| &nbsp; || &nbsp;	
|-
| 0/1	||&nbsp; ||	HDF5_version	|| NX_CHAR	|| &nbsp; || &nbsp;		
|-
| 0/1	|| &nbsp; ||	XML_version	|| NX_CHAR	|| &nbsp; || &nbsp;		
|-
| 1	|| &nbsp; ||	creator	        || NX_CHAR	|| &nbsp; || &nbsp;	
|-
| 1	|| &nbsp; ||	file_name	|| NX_CHAR	|| &nbsp; || Original file name
|-
| 1	|| &nbsp; ||	file_time	|| NX_CHAR	|| &nbsp; || Original creation time of file
|-
| 1	|| &nbsp; ||	file_update_time ||	NX_CHAR	|| &nbsp; || Last time file contents were changed
|-
| 1	|| &nbsp; || <font color=red>initial_format</font>	 || 	NX_CHAR	|| &nbsp; || 	Initial format file was created in (HDF4,HDF5 or XML) 
|-
| 0/1	|| &nbsp; ||	release_date	|| NX_CHAR	|| &nbsp; || Date of the public release of the data. (file_time + X years)
|-
| 1+	|| {entry} ||	&nbsp; || 	NXentry		|| &nbsp; || &nbsp;
|-
| 0/1	|| &nbsp; ||	unique_id	|| NX_CHAR	|| &nbsp; || UUID to uniquely identify file (even if name changes .etc). Maybe useful to have it in the NXentry instead so that you can indentify where an entry comes from even if it is copied into a new file?
|-
| 0/1	|| &nbsp; ||	revision	|| NX_CHAR	|| &nbsp; || Revision id of the file due to re-calibration, reprocessing, new analysis, new instrument definition format, ...
|}

===NXentry===

This is the top level group in a file that contains a complete set of information (e.g. a “run”) - raw, reduced, and analyzed data can occur in the same file, each as a separate NXentry . The definition  below is taken from the NeXus technical reference changing some elements to be required rather an optional. Additional items are highlighted in <font color=red>red</font>.

This definition covers a single run experiment - extensions are proposed for [[TOFRawScan|scan type experiments]]

====NXentry====
  
{| align="centre" border="1"
|-
! RE	|| Name	|| Attribute	|| Type	|| Value	|| Description
|-
| 0/1	|| title	|| &nbsp; || 	NX_CHAR	|| &nbsp;	|| run title
|-
| 1     || definition	|| &nbsp; || 	NX_CHAR	|| &nbsp;	|| Official NeXus definitions this file conforms to
|-
| 1	|| &nbsp; || 	URL	|| NX_CHAR	|| 	&nbsp; || &nbsp;
|-
| 1	|| &nbsp; || 	version	|| NX_CHAR	|| 	&nbsp; || &nbsp;
|-
| 0/1 || <font color=red>definition_local</font> || &nbsp;		|| NX_CHAR	|| &nbsp; || 	Local definition this file also conforms to – this will describe the meaning of any additional local data items etc.
|-
| 1	|| &nbsp; || 	url|| 	NX_CHAR	 || &nbsp; || &nbsp;	
|-
| 1	|| &nbsp; || 	version	|| NX_CHAR || &nbsp; || This would correspond to the ISIS Muon IDF_Version	
|-
| 1	|| start_time	|| &nbsp; || 	ISO8601	|| 	&nbsp; || Time data collection started
|-
| 1	|| end_time	|| &nbsp; || 	ISO8601	|| 	&nbsp; || Time data collection ended
|-
| 1	|| duration	|| &nbsp; || 	NX_FLOAT	|| &nbsp; || 	wall clock  time transpired (end – start)
|-
| 1	|| &nbsp; || 	units|| 	NX_CHAR|| 	second	|| &nbsp; 
|-
| 1	|| <font color=red>collection_time</font>	|| &nbsp; || 	NX_FLOAT	|| &nbsp; || 	Time transpired actually collecting data i.e. taking out time when collection was suspended due to e.g. temperature out of range 
|-
| 1	|| &nbsp; 	|| units|| 	NX_CHAR	|| second	|| &nbsp; 
|-
| 1	|| proton_charge	|| &nbsp; || 	NX_FLOAT	|| &nbsp; || &nbsp; 	
|-
| 1	|| &nbsp; 	|| units|| 	NX_CHAR	|| microAmp*hour	|| &nbsp; 
|-
| 1	|| raw_frames	|| &nbsp; ||	NX_INT	|| &nbsp; 	|| number of proton pulses on target
|-
| 1	|| good_frames	|| &nbsp; ||	NX_INT	|| &nbsp; 	|| number of proton pulses used (i.e. not vetoed)
|-
| 0/1	|| <font color=red>total_counts</font>	|| &nbsp; || 	NX_INT	|| &nbsp; || 	Total number of detector counts (events) 
|-
| 1	|| experiment_identifier || &nbsp; 	|| 	NX_CHAR	|| &nbsp; || proposal number
|-
| 1	|| run_number	|| &nbsp; 	|| NX_INT	|| &nbsp; || 	Unique number identifying this data collection
|-
| 0 /1	|| run_cycle	|| &nbsp; || 	NX_CHAR	|| &nbsp; || &nbsp;	
|-
| 0/1	|| program_name	|| &nbsp; 	|| NX_CHAR	|| &nbsp; || &nbsp; 	
|-
| 1	|| &nbsp; || 	version	|| NX_CHAR	|| &nbsp; || &nbsp; 	
|-
| 0/1	|| &nbsp; || command_line		|| NX_CHAR		|| &nbsp; || &nbsp; 
|-
| 0/1	|| notes	|| &nbsp; 	|| <font color=red>NXnote</font>	|| &nbsp; || 	User notes
|-
| 0/1	|| thumbnail	|| &nbsp; || 	NXnote	|| &nbsp; || &nbsp; 	
|-
| 1	|| &nbsp; || 	mime_type	|| NX_CHAR	|| image/* || &nbsp; 	
|-
| 0+	|| {characterisation} || &nbsp; || 		NXcharacterization || &nbsp; || &nbsp;	
|-
| 1+	|| {user1,user2,…} || &nbsp; 	|| 	NXuser	|| &nbsp; || &nbsp; 	
|-
| 1	 || {sample}	|| &nbsp; || 	NXsample		|| &nbsp; || &nbsp; 
|-
| 1	|| {instrument}	|| &nbsp; || 	NXinstrument	|| &nbsp; || &nbsp; 	
|-
| 1+	|| {monitor}|| &nbsp; 	|| 	NXmonitor		|| &nbsp; || &nbsp; 
|-
| 1+	|| {data}|| &nbsp; 	|| 	NXdata	|| &nbsp; || &nbsp; 	
|-
| 0/1	|| {process}|| &nbsp; 	|| 	NXprocess		|| &nbsp; || &nbsp; 	
|}

===NXuser===

As denoted in NXentry, there can be multiple NXuser, one for each person involved with an experiment. This definition of user requires only a name and a facility identifier and this is taken directly from the NeXus technical reference changing some elements to be required rather an optional.

{| align="centre" border="1"
|-
! RE	|| Name	|| Attribute	|| Type	|| Value|| 	Description
|-
| 1	|| name	|| &nbsp;	|| NX_CHAR		|| &nbsp; || &nbsp;
|-
| 0/1	|| role	|| &nbsp;	|| NX_CHAR	|| “local_contact”,”Principle Investigator”, …	|| &nbsp;
|-
| 0/1	|| affiliation	|| &nbsp;	|| NX_CHAR		|| &nbsp; || &nbsp;
|-
| 0/1	|| address	|| &nbsp;	|| NX_CHAR		 || &nbsp; || &nbsp;
|-
| 0/1	|| telephone_number|| &nbsp;	|| 	NX_CHAR		|| &nbsp; || &nbsp;
|-
| 0/1	|| fax_number	|| &nbsp;	|| NX_CHAR		|| &nbsp; || &nbsp;
|-
| 0/1	|| email	|| &nbsp;	|| NX_CHAR		|| &nbsp; || &nbsp;
|-
| 1	|| facility_user_id	|| &nbsp; || 	NX_CHAR || &nbsp; || &nbsp;		
|}

===NXsample===

This list is limited to items that were desired by the group. See the NeXus technical reference for a full list of possible items.

{| align="centre" border="1"
! RE	|| Name || 	Attribute|| 	Type	|| Value|| 	Description
|-
| 1|| 	Name		|| &nbsp; 	|| NX_CHAR		|| &nbsp; 	|| &nbsp; 	
|-
| 1	|| identifier		|| &nbsp; || 	NX_CHAR			|| &nbsp; || Identity given to the sample by health physics or sample environment. (Could be a bar code)
|-
| 0/1 || &nbsp; ||	Type	|| NX_CHAR	|| e.g.“barcode || &nbsp;	
|-
| 0/1	|| chemical_formula	|| &nbsp; || 		NX_CHAR		|| &nbsp; 	|| &nbsp; 	
|-
| 0/1	|| mass			|| &nbsp; || NX_FLOAT			|| &nbsp; 	|| &nbsp; 
|-
| 1	|| 	&nbsp; || units|| 	NX_CHAR			|| &nbsp; 	|| &nbsp; 
|-
| 0/1	|| volume	|| &nbsp; 	|| 	NX_FLOAT	|| &nbsp; || &nbsp;	
|-
| 1	|| &nbsp;	|| units|| 	NX_CHAR			|| &nbsp; 	|| &nbsp; 
|-
| 0/1	|| geometry || &nbsp; 	|| 	NXgeometry		|| &nbsp; 	|| &nbsp; 	
|-
| 1 ||	nature	|| &nbsp; || 	NX_CHAR	|| solid | powder | liquid | single crystal	|| &nbsp;
|-
| 0/1|| 	preparation		|| &nbsp; || 	NX_CHAR	|| &nbsp;	|| Sample handling/preparation prior to experiment
|-
| 0/1|| 	changer_position	|| &nbsp; 	|| 	NX_INT	|| &nbsp;	|| Sample changer position
|-
| 0/1	|| <font color=red>sample_holder</font>	|| &nbsp; || 	NX_CHAR || &nbsp; || &nbsp;		
|-
| 0/1	|| <font color=red>preparation_date</font>	|| &nbsp; || 	ISO8601 || &nbsp; || &nbsp;		
|-
| 0/1   || 	thickness	|| &nbsp; 	|| 	NX_FLOAT	|| &nbsp;	|| 
|-
| 0/1   || 	temperature	|| &nbsp; 	|| 	NX_FLOAT	|| &nbsp;	|| 
|}

====Sample environment parameters====

By these we mean “temperature”, “magnetic_field” etc. which may be considered to be outside of the remit of this document, but we will just add a reminder that if the file represents a scan then these values will be annotated as described in the NXentry section.

===NXinstrument===

This is the class that contains all information about instrument components except the monitors and sample (which are just inside the NXentry). This is taken directly from the NeXus technical reference changing some elements to be required rather an optional.

{| align="centre" border="1"
|-
! RE	||	Name	||	Attribute	||	Type	||	Value	||	Description
|-
| 1	|| name	|| &nbsp; ||		NX_CHAR		|| &nbsp; 	|| &nbsp; 	
|-
| 1		|| &nbsp; 	||	short_name||		NX_CHAR	|| &nbsp; 	|| &nbsp; 
|-
| 1	|| beamline || &nbsp; ||		NX_CHAR	 || &nbsp; ||		Beamline instrument is attached to
|-
| 0/1	 || &nbsp;  || &nbsp; 	||		NXsource		 || &nbsp;  || &nbsp; 
|-
| 0+	 || &nbsp;  || &nbsp; 	||		NXdisk_chopper		 || &nbsp;  || &nbsp; 
|-
| 0+	 || &nbsp;  || &nbsp; 	||		NXfermi_chopper		 || &nbsp;  || &nbsp; 
|-
| 0+	 || &nbsp;  || &nbsp; 	||		NXvelocity_selector || &nbsp;  || &nbsp; 		
|-
| 0+	 || &nbsp;  || &nbsp; 	||		NXguide		 || &nbsp;  || &nbsp; 
|-
| 0+	 || &nbsp;  || &nbsp; 	||		NXcrystal	 || &nbsp;  || &nbsp; 	
|-
| 0+	 || &nbsp;  || &nbsp; 	||		NXaperature	 || &nbsp;  || &nbsp; 	
|-
| 0+	 || &nbsp;  || &nbsp; 	||		NXfilter	 || &nbsp;  || &nbsp; 	
|-
| 0+	 || &nbsp;  || &nbsp; 	||		NXcollimator	 || &nbsp;  || &nbsp; 	
|-
| 0+	 || &nbsp;  || &nbsp; 	||		NXattenuator	 || &nbsp;  || &nbsp; 	
|-
| 0+	 || &nbsp;  || &nbsp; 	||		NXpolarizer	 || &nbsp;  || &nbsp; 	
|-
| 0+	 || &nbsp;  || &nbsp; 	||		NXflipper	 || &nbsp;  || &nbsp; 	
|-
| 0+	 || &nbsp;  || &nbsp; 	||		NXmirror	 || &nbsp;  || &nbsp; 	
|-
| 1+	 || &nbsp;  || &nbsp; ||		NXdetector	 || &nbsp;  || &nbsp; 	
|-
| 1+	 || &nbsp;  || &nbsp; ||		<font color="red">NXdetector_group</font> || &nbsp;  || &nbsp; 	
|-
| 0+	 || &nbsp;  || &nbsp; ||		NXbeam_stop	 || &nbsp;  || &nbsp; 	
|}

===NXmonitor===

{| align="centre" border="1"
|-
! RE	|| Name	|| Attribute	|| Type	|| Value	|| Description
|-
| 0/1	|| mode	 || &nbsp; 	|| NX_CHAR	|| monitor | timer	 || &nbsp; 
|-
| 0/1	|| preset	 || &nbsp; 	|| NX_FLOAT	 || &nbsp;  || &nbsp; 	
|-
| 0/1	|| distance	 || &nbsp; 	|| NX_FLOAT	 || &nbsp;  || &nbsp; 	
|-
| 0/1	 || &nbsp; 	|| units	|| NX_CHAR|| 	metre	 || &nbsp; 
|-
| 0/1	|| range	 || &nbsp; ||	NX_FLOAT[2]	 || &nbsp;  || &nbsp; 	
|-
| 1	 || &nbsp; 	|| units|| 	NX_CHAR		 || &nbsp;  || &nbsp; 
|-
| 0/1	|| integral || &nbsp; 	|| 	NX_FLOAT	 || &nbsp;  || &nbsp; 	
|-
| 1	 || &nbsp; || 	units|| 	NX_CHAR	 || &nbsp;  || &nbsp; 	
|-
| 0/1	|| integral_log	 || &nbsp; || 	NXlog	 || &nbsp; 	|| Time log of monitor integrals
|-
| 0/1	|| type	 || &nbsp; 	|| NX_CHAR		 || &nbsp;  || &nbsp; 
|-
| 1	|| time_of_flight || &nbsp; 	|| 	NX_FLOAT[i+1]		 || &nbsp;  || &nbsp; 
|-
| 1	 || &nbsp; ||	units	|| NX_CHAR	|| microsecond	 || &nbsp; 
|-
| 0/1	|| efficiency	 || &nbsp; || 	NX_FLOAT[i]	 || &nbsp;  || &nbsp; 	
|-
| 1	|| data	 || &nbsp; 	|| NX_FLOAT[i]		 || &nbsp;  || &nbsp; 
|-
| 1	||  &nbsp; 	|| units|| 	NX_CHAR	 || &nbsp;  || &nbsp; 	
|-
| 1	||  &nbsp; 	|| signal|| 	NX_INT		 || &nbsp;  || &nbsp; 
|-
| 1	|| &nbsp;	|| axes|| 	NX_CHAR	 || &nbsp;  || &nbsp; 	
|-
| 0/1	|| sampled_fraction	 || &nbsp; || 	NX_FLOAT	 || &nbsp;  || &nbsp; 	
|-
| 1	|| &nbsp;	|| units|| 	NX_CHAR	|| unitless	 || &nbsp; 
|-
| 0/1	|| geometry	 || &nbsp; 	|| NXgeometry		 || &nbsp;  || &nbsp; 
|-
| 1	|| <font color=red>monitor_number</font>  || &nbsp; 	|| 	NX_INT	 || &nbsp; || 	If monitors are numbered, this is what it is known as 
|-
| 1	|| <font color=red>detector_number</font>	 || &nbsp; || NX_INT  || &nbsp; 		|| 	Detector/spectrum number for this monitor
|}

Note that for a position sensitive monitor detector_number etc. will need to be an array and NXmonitor will have other fields and look more like NXdetector.

===NXdetector===

We will now look at possible representations of the detector – we will start with a general one and then consider the special case of an area detector. Though the general detector representation would cover all cases, if the detector is physically “rectangular” in nature there are advantages in using this symmetry in the representation. Which representation is used is recorded in the <font color=red>stored</font> attribute

====General Detector====

The general representation is to consider a detector as just a group of pixels arranged in no particular order. Each pixel will be identified by a unique single index i and then the following information will be stored:

{| align="centre" border="1"
|-
! RE	|| Name	|| Attribute	|| Type	|| Value	|| Description
|-
| 1	|| <font color=red>stored</font> || &nbsp; 	|| 	NX_CHAR		 || general  || How detector is represented:  general, centre_extent, edges or corners   
|-
| 1	|| detector_number || &nbsp; 	|| 	NX_INT[i]		 || &nbsp;  || &nbsp; 
|-
| 0/1	|| polar_angle	  || &nbsp; 	|| NX_FLOAT[i]		 || &nbsp;  || &nbsp; 
|-
| 0/1	|| azimuthal_angle || &nbsp; 	|| 	NX_FLOAT[i]	 || &nbsp;  || &nbsp; 	
|-
| 0/1	|| solid_angle || &nbsp; 	|| 	NX_FLOAT[i]	 || &nbsp;  || &nbsp; 	
|-
| 0/1	|| distance || &nbsp; 	|| 	NX_FLOAT[i]	 || distance from sample  || &nbsp; 	
|-
| 1	|| time_of_flight || &nbsp; 	|| 	NX_FLOAT[j+1]	 || &nbsp; || 	Bin boundaries
|-
| 0/1  || &nbsp; ||		units	|| NX_CHAR|| 	Micro.second  || &nbsp; 	
|-
| 0/1	|| time_of_flight_raw	 || &nbsp; 	|| NX_INT[j+1]		 || &nbsp;  || in DAQ clock pulses 
|-
| 0/1	 || &nbsp; || 	units|| 	NX_CHAR|| 	Clock_pulses	 || &nbsp; 
|-
| 0/1	 || &nbsp; 	|| frequency|| 	NX_FLOAT	|| &nbsp; || Clock frequency of acquisition system (Hz)
|-
| 1|| 	data	 || &nbsp; || 	NX_FLOAT[i,j]	 || &nbsp;  || &nbsp; 	
|-
| 0/1|| 	geometry || &nbsp; || 		NXgeometry[i]	 || &nbsp; || 	These will be relative to “Origin” below
|-
| 0/1|| 	<font color=red>group_index</font> || &nbsp; 	|| 	NX_INT[i]	 || &nbsp; || 	Detector grouping information – see NXdetector_groups class
|}

The detector data would be plotted with axes (detector number, tof) by any program. An NXgeometry object included in the detector contains arrays that store the position and orientation of each pixel. As this detector representation imposes no constraint on the relationship between pixels, a single NXdetector could represent the entire instrument (so long as all detectors have the same time_of_flight) – however in practice an NXdetector and NXdata would be created for each bank.
The “origin” object provides a reference point for the pixel geometries – the “shape” part of origin is the bounding box of the entire detector/detector bank.

====Area Detector====

We will start off by considering a flat rectangular area detector. While this could be described by the “general” representation above, taking account of the two dimensional symmetry of the detector allows several potential savings in the calculation of angles and in plotting time of the data. An area detector will have indices (i,j) indexing each pixel with i along the local detector “x” axis  and j along the local detector “y”. In the case of curved detectors the offsets and sizes are to be considered as arc lengths along the face of the detector. An offset of “0” is the origin of the detector and the NXgeometry named “origin” describes the geometry of the entire detector: the NXtranslation part describes the position of the detector, the NXorientation part defines the local coordinates (local x and y axes) with respect to the global position, and the NXshape describe the size (bounding box) and topology of the detector as a whole. The NXgeometry named “geometry” describes the  pixels and their shape (assuming that they are uniform). The necessary shapes are: rectangular prism, cylindrical slice, and spherical slice.

Below are the three cases for describing the pixels on a detector.

'''Centre and Extent'''

{| align="centre" border="1"
|-
! RE	|| Name	|| Attribute	|| Type|| 	Value|| 	Description
|-
| 1	|| <font color=red>stored</font> || &nbsp; 	|| 	NX_CHAR		 || centre_extent  || How detector is represented:  general, centre_extent, edges or corners
|-
| 1	|| detector_number	 || &nbsp; 	|| NX_INT[i,j]	 || &nbsp;  || &nbsp; 	
|-
| 1	|| polar_angle	  || &nbsp; 	|| NX_FLOAT[i,j]		 || &nbsp;  || &nbsp; 
|-
| 1	|| azimuthal_angle || &nbsp; || 		NX_FLOAT[i,j]		 || &nbsp;  || &nbsp; 
|-
| 1	|| distance || &nbsp; 	|| 	NX_FLOAT[i,j]	 || &nbsp;  || &nbsp; 	
|-
| 1	|| time_of_flight	 || &nbsp; || 	NX_FLOAT[k+1]	 || &nbsp; || 	Bin boundaries
|-
| 0/1  || &nbsp; 	||	Units|| 	NX_CHAR|| 	Micro.second	 || &nbsp; 
|-
| 1	|| raw_time_of_flight	 || &nbsp; 	|| NX_INT[k+1]		 || &nbsp;  || in DAQ clock pulses
|-
| 0/1  || &nbsp; ||		Units	|| NX_CHAR	|| Clock_pulses	 || &nbsp; 
|-
| 0/1  || &nbsp; ||		Frequency|| 	NX_FLOAT	|| 	Clock frequency || &nbsp; 
|-
| 1	|| data	 || &nbsp; || 	NX_FLOAT[i,j,k]		 || &nbsp;  || &nbsp; 
|-
| 0/1	|| geometry	 || &nbsp; || 	NXgeometry[i,j]	 || &nbsp; || 	These will be relative to “Origin” below
|-
| 0/1	|| x_pixel_offset	 || &nbsp; || 	NX_FLOAT[i]	 || &nbsp;  || 0 at origin 	
|-
| 0/1	|| x_pixel_size		 || &nbsp; || NX_FLOAT[i]	 || &nbsp;  || &nbsp; 	
|-
| 0/1	|| y_pixel_offset	 || &nbsp; || 	NX_FLOAT[j]	 || &nbsp;  || 0 at origin	
|-
| 0/1	|| y_pixel_size		 || &nbsp; || NX_FLOAT[j]	 || &nbsp;  || &nbsp; 	
|-
| 0/1	|| <font color=red>x_radius</font>	 || &nbsp; || 	NX_FLOAT	 || &nbsp; || 	If we are curved, the radius of curvature ( *_offset above will then be arc lengths)
|-
| 0/1	|| <font color=red>y_radius</font>	 || &nbsp; || 	NX_FLOAT	 || &nbsp; || 	If we are curved, the radius of curvature ( *_offset above will then be arc lengths)
|}
You can either specify an NXgeometry[i,j] for the pixels or instead use the x_pixel_* arrays. By specifying both size and offset “dead space” between pixels can be accounted for.

azimuthal_angle, polar_angle and distance can be left out of NXdetector as they can be calculated from the detector geometry

'''Edges'''

{| align="centre" border="1"
|-
! RE	|| Name	|| Attribute	|| Type	|| Value|| 	Description
|-
| 1	|| <font color=red>stored</font> || &nbsp; 	|| 	NX_CHAR		 || edges  || How detector is represented:  general, centre_extent, edges or corners
|-
| 1	|| detector_number	 || &nbsp; 	|| NX_INT[i,j]	 || &nbsp;  || &nbsp; 	
|-
| 1	|| polar_angle	 || &nbsp; ||  	NX_FLOAT[i,j]		 || &nbsp;  || &nbsp; 
|-
| 1 	|| azimuthal_angle || &nbsp; 	|| 	NX_FLOAT[i,j]	 || &nbsp;  || &nbsp; 	
|-
| 1	|| distance	 || &nbsp; || 	NX_FLOAT[i,j]		 || &nbsp;  || &nbsp; 
|-
| 1	|| time_of_flight || &nbsp; 	|| 	NX_FLOAT[k+1]	 || &nbsp; || 	Bin boundaries
|-
| 0/1	 || &nbsp; || 	Units	|| NX_CHAR	|| Micro.second	  || &nbsp; 
|-
| 1	|| raw_time_of_flight	 || &nbsp; 	|| NX_FLOAT[k+1]	 || &nbsp;  || &nbsp; 	
|-
| 0/1  || &nbsp; 		|| Units	|| NX_CHAR|| 	Clock_pulses	 || &nbsp; 
|-
| 0/1	 || &nbsp; 	|| Frequency|| 	NX_FLOAT	|| 	Clock frequency || &nbsp; 
|-
| 1	|| data	 || &nbsp; 	|| NX_FLOAT[i,j,k]		 || &nbsp;  || &nbsp; 
|-
| 0/1	|| geometry || &nbsp; || 		NXgeometry[i,j]		 || &nbsp;  || &nbsp; 
|-
| 0/1|| 	x_pixel_offset	 || &nbsp; 	|| NX_FLOAT[i+1]	 || &nbsp;  || &nbsp; 	
|-
| 0/1	|| y_pixel_offset	 || &nbsp; || 	NX_FLOAT[j+1]	 || &nbsp;  || &nbsp; 	
|}					

All pixels are edge to edge.

'''Corners'''


{| align="centre" border="1"
|-
! RE ||	Name||	Attribute||	Type	|| Value	 || Description
|-
| 1	|| <font color=red>stored</font> || &nbsp; 	|| 	NX_CHAR		 || corners  || How detector is represented:  general, centre_extent, edges or corners
|-
| 1	|| detector_number || &nbsp; 	|| 	NX_INT[i,j]	 || &nbsp;  || &nbsp; 	
|-
| 1	|| polar_angle	 || &nbsp;  || 	NX_FLOAT[i,j]	 || &nbsp;  || &nbsp; 	
|-
| 1|| 	azimuthal_angle	 || &nbsp; || 	NX_FLOAT[i,j]	 || &nbsp;  || &nbsp; 	
|-
| 1	|| distance	 || &nbsp; || 	NX_FLOAT[i,j]	 || &nbsp;  || &nbsp; 	
|-
| 1	|| time_of_flight || &nbsp; 	|| 	NX_FLOAT[k+1]	 || &nbsp; || 	Bin boundaries
|-
| 0/1  || &nbsp; 	||	Units	|| NX_CHAR	|| Micro.second	 || &nbsp; 
|-
| 1	|| raw_time_of_flight || &nbsp; 	|| 	NX_FLOAT[k+1]		 || &nbsp;  || &nbsp; 
|-
| 0/1  || &nbsp;  	|| 	Units	|| NX_CHAR|| 	Clock_pulses	 || &nbsp; 
|-
| 0/1	 || &nbsp; || 	Frequency|| 	NX_FLOAT|| 		Clock frequency || &nbsp; 
|-
| 1	|| data	 || &nbsp; || 	NX_FLOAT[i,j,k]	 || &nbsp;  || &nbsp; 	
|-
| 0/1	|| geometry	 || &nbsp; || 	NXgeometry[i,j]		 || &nbsp;  || &nbsp; 
|-
| 0/1	|| x_pixel_offset || &nbsp; 	|| 	NX_FLOAT[i+1, j+1]		 || &nbsp;  || &nbsp; 
|-
| 0/1	|| y_pixel_offset	 || &nbsp; || 	NX_FLOAT[i+1,j+1]	 || &nbsp;  || &nbsp; 	
|}					

'''Hardware ganging of detector elements'''

In some cases individual detector elements are ganged together by the acquisition system for symmetry reasons or to create a smaller data files. In these cases the above formalisms can still be used, but the “detector number” does not correspond to a real physical detector and so the values of “polar_angle”, “distance”, “azimuthal_angle” are some sort of average over the ganged elements. When analysis and simulation of the data is performed, it is sometimes necessary to know the details of the individual detectors that have been ganged together. The proposal is that in these cases additional arrays would be stored with the “_unganged” suffix e.g. “Polar_angle_unganged”, “distance_unganged”, “detector_number_unganged”. The “unganged” arrays are arranged so that elements that are ganged together appear sequentially and information to relate these arrays to the hardware ganged “polar_angle” etc arrays are provided by

{| align="centre" border="1"
! RE  || Name       || Attribute || Type      || Value || Description
|-
| 0/1 || <font color=red>gang_count</font> || &nbsp;    || NX_INT[i]  || Number of physical detectors elements ganged together  || &nbsp; 
|-
| 0/1 || <font color=red>gang_index</font> || &nbsp;    || NX_INT[i]  || Index of first ganged element	 || &nbsp; 
|}

Detector_number[i] is ganged from gang_count[i] elements. The values of polar_angle[i] was obtained by average the gang_count[i] values of polar_angle_unganged[gang_index[i]], polar_angle_unganged[gang_index[i]+1], … , polar_angle[gang_index[i]+gang_count[i]-1]

===NXdata===

{| align="centre" border="1"
! RE  || Name       || Attribute  || Type      || Value || Description
|-
| 0/1  || &nbsp;  || &nbsp; ||		NXdata		 || &nbsp;  || &nbsp; 
|-
| 1   || data	    || &nbsp;     || NX_FLOAT[i,j,k,m]	 || &nbsp;  || &nbsp; 	
|-
| 1   || &nbsp;     || units	  || NX_CHAR		 || &nbsp;  || &nbsp; 
|-
| 1   || &nbsp;     || long_name	  || NX_CHAR		 || &nbsp;  || Title of data
|-
| 1   || time_of_flight || &nbsp; || NX_FLOAT[k+1]		 || &nbsp;  || &nbsp; 
|-
| 0/1   || x_pixel_offset	|| &nbsp; || NX_FLOAT[i]		 || &nbsp;  || &nbsp; 
|-
| 0/1   || y_pixel_offset	|| &nbsp; || NX_FLOAT[j]		 || &nbsp;  || &nbsp; 
|-

|}

The exact format of  this will depend on the NXdetector definition used.

===NXmoderator===

The moderator is the effective source for all time-of-flight instruments. This is taken directly from the NeXus technical reference changing some elements to be required rather an optional. Additional items are in red.

{| align="centre" border="1"
! RE  || Name       || Attribute  || Type      || Value || Description
|-
| 1	|| distance	 || &nbsp; 	||NX_FLOAT || &nbsp;  || &nbsp; 		
|-
| 1	|| &nbsp; ||	units	||NX_CHAR || &nbsp;  || &nbsp; 		
|-
| 1	|| type	 || &nbsp; 	||NX_CHAR	 || &nbsp; || The moderator material
|-
| 0/1	|| poison_depth	 || &nbsp; 	||NX_FLOAT	 || &nbsp;  || &nbsp; 	
|-
| 1	|| &nbsp; ||	units	||NX_CHAR || &nbsp;  || &nbsp; 		
|-
| 0/1	|| coupled || &nbsp; 	||NX_BOOLEAN	 || &nbsp;  || &nbsp; 	
|-
| 0/1	|| poison_material	 || &nbsp; 	||NX_CHAR		 || &nbsp;  || &nbsp; 
|-
| 1	|| temperature || &nbsp; 	||	NX_FLOAT || &nbsp;  || &nbsp; 		
|-
| 1	|| &nbsp; ||	units	|| NX_CHAR	||Kelvin || &nbsp; 	
|-
| 0/1	|| temperature_log || &nbsp; 	||	NXlog	 || &nbsp;  || &nbsp; 	
|-
| 0/1	|| pulse_shape	 || &nbsp; ||	NXdata		 || &nbsp;  || &nbsp; 
|-
| 0/1	|| geometry || &nbsp;  ||		NXgeometry || &nbsp;  || &nbsp; 		
|}

===NXgeometry===

This group describes the shape, position, and orientation of a component. Almost all of the information is actually stored in subgroups. This is taken directly from the NeXus technical reference without change.

{| align="centre" border="1"
! RE  || Name       || Attribute  || Type      || Value || Description
|-
| 0/1 || &nbsp; || &nbsp; ||			NXshape		|| &nbsp; || &nbsp; 
|-
| 0/1	|| &nbsp; || &nbsp;  ||		NXtranslation		|| &nbsp; || &nbsp; 
|-
| 0/1	|| &nbsp; || &nbsp;  ||		NXorientation		|| &nbsp; || &nbsp; 
|-
| 0/1	|| description	|| &nbsp;  ||	NX_CHAR	|| &nbsp; || &nbsp; 	
|-
| 0/1	|| component_index	|| &nbsp;  ||	NX_INT		|| &nbsp;  ||Position of component along the beam path. 
|}
The sample has a component_index of 0, components upstream have negative component_index.

===NXlog===
Contains log information monitored during the run in a timed fashion.  This can contain the time-stamped values, or the average (with standard deviation), minimum, maximum and total time log was taken. This is taken directly from the NeXus technical reference without change.

{| align="centre" border="1"
! RE  || Name       || Attribute  || Type      || Value || Description
|-
| 0/1 ||	time	|| &nbsp; ||	NX_FLOAT|| &nbsp; || relative to "start" 		
|-
| 1	|| &nbsp; ||	units	|| NX_CHAR		|| &nbsp; || &nbsp; 
|-
| 1	|| &nbsp; ||	start	|| ISO8601		|| &nbsp; || start time of logging
|-
| 0/1 ||	value	|| &nbsp; ||	NX_FLOAT / NX_INT		|| &nbsp; || &nbsp; 
|-
| 1	|| &nbsp; ||	units	|| NX_CHAR		|| &nbsp; || &nbsp; 
|-
| 0/1	|| raw_value	|| &nbsp; 	|| NX_FLOAT / NX_INT		|| &nbsp; || e.g. voltage from thermocouple
|-
| 1	|| &nbsp; ||	units	|| NX_CHAR		|| &nbsp; || &nbsp; 
|-
| 0/1	|| description	|| &nbsp; 	|| NX_CHAR		|| &nbsp; || &nbsp; 
|-
| 0/1	|| average_value|| &nbsp; 	|| 	NX_FLOAT		|| &nbsp; || &nbsp; 
|-
| 1	|| &nbsp; || 	units	|| NX_CHAR		|| &nbsp; || &nbsp; 
|-
| 0/1	|| average_value_error|| &nbsp; 	|| 	NX_FLOAT		|| &nbsp; || &nbsp; 
|-
| 1	|| &nbsp; || 	units	|| NX_CHAR		|| &nbsp; || &nbsp; 
|-
| 0/1	|| minimum_value	|| &nbsp; || 	NX_FLOAT		|| &nbsp; || &nbsp; 
|-
| 1	|| &nbsp; 	|| units	|| NX_CHAR		|| &nbsp; || &nbsp; 
|-
| 0/1	|| maximum_value	|| &nbsp; || 	NX_FLOAT		|| &nbsp; || &nbsp; 
|-
| 1	|| &nbsp; 	|| units	|| NX_CHAR		|| &nbsp; || &nbsp; 
|-
| 0/1	|| duration	|| &nbsp; 	|| NX_FLOAT		|| &nbsp; || &nbsp; 
|-
| 1	|| &nbsp; 	|| units	|| NX_CHAR		|| &nbsp; || &nbsp; 
|-
| 0/1	|| <font color=red>display_name</font>	|| &nbsp; 	|| NX_CHAR		|| &nbsp; || short name displayed on instrument  dashboard 
|-
| 0/1	|| <font color=red>software</font>	|| &nbsp; 	|| NX_CHAR		|| &nbsp; || program or software used to measure value  
|-
| 0/1	|| <font color=red>hardware</font>	|| &nbsp; 	|| NX_CHAR		|| &nbsp; || hardware used to measure value  
|}

===NXorientation===

{| align="centre" border="1"
! RE  || Name       || Attribute  || Type      || Value || Description
|-
| 0/1	|| &nbsp; ||	&nbsp; 	|| NXgeometry	|| &nbsp; 	|| Link to another object for relative positioning
|-
| 0/1	|| value|| &nbsp; 	||	NX_FLOAT[numobj,6]	|| &nbsp; ||	The orientation information is stored as 6 direction cosines for each object
|}

===NXshape===

{| align="centre" border="1"
! RE  || Name       || Attribute  || Type      || Value || Description
|-
| 0/1	|| shape|| &nbsp; 	|| 	NX_CHAR	|| nxcylinder|nxbox|nxsphere	|| &nbsp; 
|-
| 0/1	|| size	|| &nbsp; 	|| NX_FLOAT[numobj, nshapepar]	|| &nbsp; || &nbsp; 	
|-
| 1	|| &nbsp; || 	units	|| NX_CHAR|| 	metre	|| &nbsp; 
|}

The interpretation of the “shapepar” depends on the “shape”

===NXtranslation===

{| align="centre" border="1"
! RE  || Name       || Attribute  || Type      || Value || Description
|-
| 0/1	|| &nbsp; || &nbsp; 	|| 	NXgeometry		|| &nbsp; || Link to another object for relative positioning
|-
| 0/1	|| distance|| &nbsp; 	|| 	NX_FLOAT[numobj,3]	|| &nbsp; || &nbsp; 	
|-
| 1	|| &nbsp; || 	Units	|| NX_CHAR|| 	metre	|| &nbsp; 
|}

===NXevent_data===

This requires that a Pixel_number field is provided in the NXdetector for determining geometry information. While normally this takes the place of the NXdata in a NXentry, there is no reason that the two cannot coexist. The index I runs over events - the index j runs counts pulses. 

{| align="centre" border="1"
! RE  || Name       || Attribute  || Type      || Value || Description
|-
| 0/1	|| time_of_flight	|| &nbsp; || 	NX_INT[i]	|| &nbsp; || A list of time of flight for each event as it comes in. This list is for all pulses with information to attach to a particular pulse located in events_per_pulse
|-
| 1	|| &nbsp; || 	units|| 	NX_CHAR	|| 	Micro.second|| &nbsp; 
|-
| 0/1	|| pixel_number	|| &nbsp; 	|| NX_INT[i]	|| &nbsp; || 	There will be extra information in the NXdetector to convert pixel_number to detector_number. This list is for all pulses with information to attach to a particular pulse located in events_per_pulse
|-
| 0/1	|| pulse_time	|| &nbsp;  	|| NX_INT[j]	|| &nbsp; || 	The time that each pulse started with respect to the offset
|-
| 1 || &nbsp; ||  Units || NX_CHAR || &nbsp; || &nbsp; 			
|-
| 1|| &nbsp; 	|| 	Offset	|| ISO8601		|| &nbsp; || &nbsp; 
|-
| 0/1	|| events_per_pulse|| &nbsp; 	|| 	NX_INT[j]	|| &nbsp; || 	This connects the index "i" to the index "j". The jth element is the number of events in "i" that occured during the jth pulse
|-
| 0/1	|| pulse_height	|| &nbsp; || 	NX_FLOAT[I,k?]		|| &nbsp; || If voltages from the ends of the detector are read out this is where they go. This list is for all events with information to attach to a particular pulse height. The information to attach to a particular pulse is located in events_per_pulse
|}

===NXsource===

{| align="centre" border="1"
! RE  || Name       || Attribute  || Type      || Value || Description
|-
| &nbsp;	|| NXsource	|| &nbsp; 	|| &nbsp; || 	Name of source	|| &nbsp; 
|-
| 1	|| name	|| &nbsp; 	|| NX_CHAR	|| &nbsp; || Facility name	
|-
| 1	|| type	|| &nbsp; 	|| NX_CHAR	|| "Spallation Neutron Source" | ”Pulsed Reactor Source” | ”Reactor Neutron Source” | “Synchrotron X-ray Source”	|| &nbsp; 
|-
| 1	|| probe	|| &nbsp; || 	NX_CHAR	|| “neutrons” | “muons” | “x-rays”	|| &nbsp; 
|-
| 1	|| frequency	|| &nbsp;  || 	NX_FLOAT32|| &nbsp; || 	Frequency of pulsed source at the target	“at target” allows for the main proton beam being split with.g. 1 in 5 pulses diverted to another target
|-
| 1	|| &nbsp; || 	units	|| NX_CHAR	|| Hertz	|| &nbsp; 
|-
|0/1	|| period	|| &nbsp; || 	NX_FLOAT	|| &nbsp; || &nbsp; 	
|-
| 0/1 || &nbsp; ||	units	|| 	NX_CHAR|| microseconds	|| Length of an acquisition frame
|-
| 0/1	|| notes	|| &nbsp; || 	NX_TEXT	|| Source/facility related messages or announcements during the experiment	|| At ISIS, the MCR beam messages
|}

===NXdetector_groups===
This class is used to allow a logical grouping of detector elements (e.g. which tube, bank or group of banks) to be recorded in the file. As well as allowing you to e.g just select the “left” or “east” detectors, it may also be useful for determining which elements belong to the same PSD tube and hence have e.g. the same dead time.

{| align="centre" border="1"
! RE  || Name       || Attribute  || Type      || Value || Description
|-
| RE	|| Name 	|| Attribute	|| Type || 	Value || 	Description 
|-
| 1	|| group_names	|| &nbsp; 	|| NX_CHAR	|| &nbsp; || Comma separated list of name 	
|-
| 1	|| group_index	|| &nbsp; 	|| NX_INT[i]|| &nbsp; || 	Unique ID for group	
|-
| 1	|| group_parent	|| &nbsp; 	|| NX_INT[i]	|| Index of group parent in the hierarchy	|| -1 means no parent i.e. a top level group
|-
| 1	|| group_type	|| &nbsp; 	|| NX_INT[i]	|| 	Code number for group type || e.g. bank=1, tube=2 etc.
|}

For example of we had “bank1” composed of “tube1”, “tube2” and “tube3” then
Group_names would be the string “bank1, bank1/tube1, bank1/tube2,bank1/tube3”
Group_index would be {1,2,3,4}
Group_parent would be {-1,1,1,1}

The mapping array is interpreted as group 1 is a top level group containing groups 2, 3 and 4

A group_index array in NXdetector give the base group for a detector element.